Data structures can be viewed as adding "context" to some set of values, where the context is the actual constructor used.
For instance, any structure containing a single value can be easily converted to a one-tuple (tuple of length one),
since both contain a single value. The names and constructors just provide us with the context for the data.

Many data structures have multiple contexts, though (Maybe and [] being two examples).
So it makes sense to have some kind of generic function for shifting between multiple contexts of one data type:

< shift :: Context c => (c a -> c b) -> c a -> c b
< shift f c = f c

In fact, this exists in a more general form:

< ($) :: (a -> b) -> a -> b
< f $ x = f x

Let's address a slightly more specific way of switching context:
one where we can generate the new context and value by only knowing the old value.

< shift :: Context c => (a -> c b) -> c a -> c b

That becomes much more interesting! Hence the Monad typeclass:

> class Monad m where
>     (>>=) :: m a -> (a -> m b) -> m b

The arguments of (>>=) are reversed, but it's otherwise the same as what we wrote.
Monads have more functions, though:

>     return :: a -> m a

>     (>>) :: m a -> m b -> m b
>     x >> y = x >>= const y

>     (=<<) :: (a -> m b) -> m a -> m b
>     x =<< y = y >>= x

The `return` function is analogous to our `pure` function from Applicatives, and the two other operators are there for simplicity.
Let's see some instances:

> instance Monad Maybe where
>     return = Just
<     (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
>     (Just x) >>= f = f x
>     Nothing >>= _ = Nothing

So if we have a value to pass, we pass it to the function.
Otherwise, we stay where we are.

> instance Monad [] where
>     return x = [x]
<     (>>=) :: [a] -> (a -> [b]) -> [b]
>     (x:xs) >>= f = f x ++ (xs >>= f)
>     [] >>= _ = []

So we just stick together all the lists generated by applying the function to the whole list.
The library function `concatMap` can be written as:

> concatMap :: (a -> [b]) -> [a] -> [b]
> concatMap f xs = foldr (++) [] $ map f xs -- foldr (++) [] (map f xs)

This uses `foldr`

< foldr :: (a -> b -> b) -> b -> [a] -> [b]
< foldr _ b [] = b
< foldr f b (x:xs) = f x $ foldr f b xs

Monads are used frequently enough to have their own special syntax:

< do { x <- m; ... } = m >>= (\x -> ...)
< do { m; ... } = m >> ...

It can also be written on several lines, and then the semicolons and braces can be omitted (which is way more common):

> highScoreDiff :: Maybe Int -> Maybe Int -> Maybe Int
> highScoreDiff score1 score2 = do i <- score1
>                                  j <- score2
>                                  return $ diff i j -- return (diff i j)
>     where diff i j = abs (i - j)

Usually, using `return` inside a `do` notation can be avoided by using Functors and Applicatives,
as we did with the previous `highScoreDiff` function.

In Haskell, IO computations are modeled using data structures wrapping function calls, and they are instances of Monad,
so we can use them with do-notation quite nicely.

Some examples are:

< putStr :: String -> IO ()
< getLine :: IO String
< putStrLn :: String -> IO ()
< putStrLn s = putStr s >> putStr "\n"

The () type is a zero-tuple, and is commonly used as a "void" type.
In general, the type signature `IO a` should be understood as an IO action returning type `a`.

> main :: IO ()
> main = do
>           putStr "Enter a string: "
>           s <- getLine
>           putStrLn $ "You said " ++ s

Now you can finally write hello world.
