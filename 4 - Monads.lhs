> import Prelude hiding (Monad, putStrLn)

Some data structures, we call them `Monads`, have some kind of context to the value they contain -
a context necessary for the Monad to have meaning.
For instance, a `Maybe a` cannot be converted to an `a` without losing the conditional nature of the `Maybe`;
a list cannot be converted to an element without losing the plurality of the list.

Since we can't extract values from these contexts, we instead work with them from *within* the context.

> class Monad m where
>     (>>=) :: m a -> (a -> m b) -> m b

Monads have some other functions, though:

>     return :: a -> m a

>     (>>) :: m a -> m b -> m b
>     x >> y = x >>= const y

>     (=<<) :: (a -> m b) -> m a -> m b
>     x =<< y = y >>= x

The `return` function is essential `pure` from `Applicative`,
and the two operators are minor simplicity operators.

> instance Monad Maybe where
>     return = Just

<     (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b

>     (Just x) >>= f = f x
>     Nothing >>= _ = Nothing

So if we have a value to pass, we pass it to the function.
Otherwise, we stay where we are.

> instance Monad [] where
>     return x = [x]

<     (>>=) :: [a] -> (a -> [b]) -> [b]

>     (x:xs) >>= f = f x ++ (xs >>= f)
>     [] >>= _ = []

So we just stick together all the lists generated by applying the function to the whole list.
Monads are used frequently enough to have their own special syntax:

< do { x <- m; ... } = m >>= (\x -> ...)
< do { m; ... } = m >> ...

It can also be written on several lines, and then the semicolons and braces can be omitted (which is way more common):

> highScoreDiff :: Maybe Int -> Maybe Int -> Maybe Int
> highScoreDiff score1 score2 = do i <- score1
>                                  j <- score2
>                                  return $ diff i j -- return (diff i j)
>     where diff i j = abs (i - j)

Usually, using `return` inside a `do` notation can be avoided by using `Functor` and `Applicative`,
as we did with the previous `highScoreDiff` function.

In Haskell, IO computations are done through Monads, so we can use them with do-notation quite nicely.

Some examples are:

< putStr :: String -> IO ()
< getLine :: IO String

> putStrLn :: String -> IO ()
> putStrLn s = putStr s >> putStr "\n"

The () type is a zero-tuple, and is commonly used as a "void" type.
In general, the type signature `IO a` should be understood as an IO action returning type `a`.

> main :: IO ()
> main = do
>           putStr "Enter a string: "
>           s <- getLine
>           putStrLn ("You said " ++ s)

Now you can finally write hello world.
